// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: ucw/v1/ucw.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingRequestMultiError, or
// nil if none found.
func (m *PingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PingRequestMultiError(errors)
	}

	return nil
}

// PingRequestMultiError is an error wrapping multiple validation errors
// returned by PingRequest.ValidateAll() if the designated constraints aren't met.
type PingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingRequestMultiError) AllErrors() []error { return m }

// PingRequestValidationError is the validation error returned by
// PingRequest.Validate if the designated constraints aren't met.
type PingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingRequestValidationError) ErrorName() string { return "PingRequestValidationError" }

// Error satisfies the builtin error interface
func (e PingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingRequestValidationError{}

// Validate checks the field values on PingReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PingReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PingReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PingReplyMultiError, or nil
// if none found.
func (m *PingReply) ValidateAll() error {
	return m.validate(true)
}

func (m *PingReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return PingReplyMultiError(errors)
	}

	return nil
}

// PingReplyMultiError is an error wrapping multiple validation errors returned
// by PingReply.ValidateAll() if the designated constraints aren't met.
type PingReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PingReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PingReplyMultiError) AllErrors() []error { return m }

// PingReplyValidationError is the validation error returned by
// PingReply.Validate if the designated constraints aren't met.
type PingReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PingReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PingReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PingReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PingReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PingReplyValidationError) ErrorName() string { return "PingReplyValidationError" }

// Error satisfies the builtin error interface
func (e PingReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPingReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PingReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PingReplyValidationError{}

// Validate checks the field values on LoginRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginRequestMultiError, or
// nil if none found.
func (m *LoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetEmail()); err != nil {
		err = LoginRequestValidationError{
			field:  "Email",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginRequestMultiError(errors)
	}

	return nil
}

func (m *LoginRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *LoginRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// LoginRequestMultiError is an error wrapping multiple validation errors
// returned by LoginRequest.ValidateAll() if the designated constraints aren't met.
type LoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginRequestMultiError) AllErrors() []error { return m }

// LoginRequestValidationError is the validation error returned by
// LoginRequest.Validate if the designated constraints aren't met.
type LoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginRequestValidationError) ErrorName() string { return "LoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginRequestValidationError{}

// Validate checks the field values on LoginReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginReplyMultiError, or
// nil if none found.
func (m *LoginReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if len(errors) > 0 {
		return LoginReplyMultiError(errors)
	}

	return nil
}

// LoginReplyMultiError is an error wrapping multiple validation errors
// returned by LoginReply.ValidateAll() if the designated constraints aren't met.
type LoginReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginReplyMultiError) AllErrors() []error { return m }

// LoginReplyValidationError is the validation error returned by
// LoginReply.Validate if the designated constraints aren't met.
type LoginReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginReplyValidationError) ErrorName() string { return "LoginReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginReplyValidationError{}

// Validate checks the field values on GetUserInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoRequestMultiError, or nil if none found.
func (m *GetUserInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetUserInfoRequestMultiError(errors)
	}

	return nil
}

// GetUserInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoRequest.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoRequestMultiError) AllErrors() []error { return m }

// GetUserInfoRequestValidationError is the validation error returned by
// GetUserInfoRequest.Validate if the designated constraints aren't met.
type GetUserInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoRequestValidationError) ErrorName() string {
	return "GetUserInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoRequestValidationError{}

// Validate checks the field values on GetUserInfoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoReplyMultiError, or nil if none found.
func (m *GetUserInfoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserInfoReplyValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserInfoReplyValidationError{
				field:  "Vault",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWallet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserInfoReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWallet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserInfoReplyValidationError{
				field:  "Wallet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetUserNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserInfoReplyValidationError{
						field:  fmt.Sprintf("UserNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserInfoReplyValidationError{
						field:  fmt.Sprintf("UserNodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserInfoReplyValidationError{
					field:  fmt.Sprintf("UserNodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserInfoReplyMultiError(errors)
	}

	return nil
}

// GetUserInfoReplyMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoReply.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoReplyMultiError) AllErrors() []error { return m }

// GetUserInfoReplyValidationError is the validation error returned by
// GetUserInfoReply.Validate if the designated constraints aren't met.
type GetUserInfoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoReplyValidationError) ErrorName() string { return "GetUserInfoReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetUserInfoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoReplyValidationError{}

// Validate checks the field values on BindNodeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BindNodeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindNodeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindNodeRequestMultiError, or nil if none found.
func (m *BindNodeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BindNodeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	if len(errors) > 0 {
		return BindNodeRequestMultiError(errors)
	}

	return nil
}

// BindNodeRequestMultiError is an error wrapping multiple validation errors
// returned by BindNodeRequest.ValidateAll() if the designated constraints
// aren't met.
type BindNodeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindNodeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindNodeRequestMultiError) AllErrors() []error { return m }

// BindNodeRequestValidationError is the validation error returned by
// BindNodeRequest.Validate if the designated constraints aren't met.
type BindNodeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindNodeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindNodeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindNodeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindNodeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindNodeRequestValidationError) ErrorName() string { return "BindNodeRequestValidationError" }

// Error satisfies the builtin error interface
func (e BindNodeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindNodeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindNodeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindNodeRequestValidationError{}

// Validate checks the field values on BindNodeReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BindNodeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindNodeReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BindNodeReplyMultiError, or
// nil if none found.
func (m *BindNodeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BindNodeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUserNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BindNodeReplyValidationError{
					field:  "UserNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BindNodeReplyValidationError{
					field:  "UserNode",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BindNodeReplyValidationError{
				field:  "UserNode",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BindNodeReplyMultiError(errors)
	}

	return nil
}

// BindNodeReplyMultiError is an error wrapping multiple validation errors
// returned by BindNodeReply.ValidateAll() if the designated constraints
// aren't met.
type BindNodeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindNodeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindNodeReplyMultiError) AllErrors() []error { return m }

// BindNodeReplyValidationError is the validation error returned by
// BindNodeReply.Validate if the designated constraints aren't met.
type BindNodeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindNodeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindNodeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindNodeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindNodeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindNodeReplyValidationError) ErrorName() string { return "BindNodeReplyValidationError" }

// Error satisfies the builtin error interface
func (e BindNodeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindNodeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindNodeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindNodeReplyValidationError{}

// Validate checks the field values on InitVaultRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InitVaultRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitVaultRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitVaultRequestMultiError, or nil if none found.
func (m *InitVaultRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitVaultRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return InitVaultRequestMultiError(errors)
	}

	return nil
}

// InitVaultRequestMultiError is an error wrapping multiple validation errors
// returned by InitVaultRequest.ValidateAll() if the designated constraints
// aren't met.
type InitVaultRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitVaultRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitVaultRequestMultiError) AllErrors() []error { return m }

// InitVaultRequestValidationError is the validation error returned by
// InitVaultRequest.Validate if the designated constraints aren't met.
type InitVaultRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitVaultRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitVaultRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitVaultRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitVaultRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitVaultRequestValidationError) ErrorName() string { return "InitVaultRequestValidationError" }

// Error satisfies the builtin error interface
func (e InitVaultRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitVaultRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitVaultRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitVaultRequestValidationError{}

// Validate checks the field values on InitVaultReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InitVaultReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitVaultReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InitVaultReplyMultiError,
// or nil if none found.
func (m *InitVaultReply) ValidateAll() error {
	return m.validate(true)
}

func (m *InitVaultReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitVaultReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitVaultReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitVaultReplyValidationError{
				field:  "Vault",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitVaultReplyMultiError(errors)
	}

	return nil
}

// InitVaultReplyMultiError is an error wrapping multiple validation errors
// returned by InitVaultReply.ValidateAll() if the designated constraints
// aren't met.
type InitVaultReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitVaultReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitVaultReplyMultiError) AllErrors() []error { return m }

// InitVaultReplyValidationError is the validation error returned by
// InitVaultReply.Validate if the designated constraints aren't met.
type InitVaultReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitVaultReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitVaultReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitVaultReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitVaultReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitVaultReplyValidationError) ErrorName() string { return "InitVaultReplyValidationError" }

// Error satisfies the builtin error interface
func (e InitVaultReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitVaultReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitVaultReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitVaultReplyValidationError{}

// Validate checks the field values on ListGroupsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListGroupsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGroupsRequestMultiError, or nil if none found.
func (m *ListGroupsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	// no validation rules for GroupType

	if len(errors) > 0 {
		return ListGroupsRequestMultiError(errors)
	}

	return nil
}

// ListGroupsRequestMultiError is an error wrapping multiple validation errors
// returned by ListGroupsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupsRequestMultiError) AllErrors() []error { return m }

// ListGroupsRequestValidationError is the validation error returned by
// ListGroupsRequest.Validate if the designated constraints aren't met.
type ListGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupsRequestValidationError) ErrorName() string {
	return "ListGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupsRequestValidationError{}

// Validate checks the field values on ListGroupsReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListGroupsReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListGroupsReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListGroupsReplyMultiError, or nil if none found.
func (m *ListGroupsReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListGroupsReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGroups() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListGroupsReplyValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListGroupsReplyValidationError{
						field:  fmt.Sprintf("Groups[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListGroupsReplyValidationError{
					field:  fmt.Sprintf("Groups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListGroupsReplyMultiError(errors)
	}

	return nil
}

// ListGroupsReplyMultiError is an error wrapping multiple validation errors
// returned by ListGroupsReply.ValidateAll() if the designated constraints
// aren't met.
type ListGroupsReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListGroupsReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListGroupsReplyMultiError) AllErrors() []error { return m }

// ListGroupsReplyValidationError is the validation error returned by
// ListGroupsReply.Validate if the designated constraints aren't met.
type ListGroupsReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListGroupsReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListGroupsReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListGroupsReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListGroupsReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListGroupsReplyValidationError) ErrorName() string { return "ListGroupsReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListGroupsReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListGroupsReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListGroupsReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListGroupsReplyValidationError{}

// Validate checks the field values on GetGroupRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetGroupRequestMultiError, or nil if none found.
func (m *GetGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	// no validation rules for GroupId

	if len(errors) > 0 {
		return GetGroupRequestMultiError(errors)
	}

	return nil
}

// GetGroupRequestMultiError is an error wrapping multiple validation errors
// returned by GetGroupRequest.ValidateAll() if the designated constraints
// aren't met.
type GetGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupRequestMultiError) AllErrors() []error { return m }

// GetGroupRequestValidationError is the validation error returned by
// GetGroupRequest.Validate if the designated constraints aren't met.
type GetGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupRequestValidationError) ErrorName() string { return "GetGroupRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupRequestValidationError{}

// Validate checks the field values on GetGroupReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetGroupReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetGroupReplyMultiError, or
// nil if none found.
func (m *GetGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetGroupReplyValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetGroupReplyValidationError{
					field:  "Group",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetGroupReplyValidationError{
				field:  "Group",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetGroupReplyMultiError(errors)
	}

	return nil
}

// GetGroupReplyMultiError is an error wrapping multiple validation errors
// returned by GetGroupReply.ValidateAll() if the designated constraints
// aren't met.
type GetGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetGroupReplyMultiError) AllErrors() []error { return m }

// GetGroupReplyValidationError is the validation error returned by
// GetGroupReply.Validate if the designated constraints aren't met.
type GetGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetGroupReplyValidationError) ErrorName() string { return "GetGroupReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetGroupReplyValidationError{}

// Validate checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWalletRequestMultiError, or nil if none found.
func (m *CreateWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 32 {
		err := CreateWalletRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 32 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateWalletRequestMultiError(errors)
	}

	return nil
}

// CreateWalletRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletRequestMultiError) AllErrors() []error { return m }

// CreateWalletRequestValidationError is the validation error returned by
// CreateWalletRequest.Validate if the designated constraints aren't met.
type CreateWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletRequestValidationError) ErrorName() string {
	return "CreateWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletRequestValidationError{}

// Validate checks the field values on CreateWalletReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateWalletReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWalletReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWalletReplyMultiError, or nil if none found.
func (m *CreateWalletReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWalletReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	if len(errors) > 0 {
		return CreateWalletReplyMultiError(errors)
	}

	return nil
}

// CreateWalletReplyMultiError is an error wrapping multiple validation errors
// returned by CreateWalletReply.ValidateAll() if the designated constraints
// aren't met.
type CreateWalletReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletReplyMultiError) AllErrors() []error { return m }

// CreateWalletReplyValidationError is the validation error returned by
// CreateWalletReply.Validate if the designated constraints aren't met.
type CreateWalletReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletReplyValidationError) ErrorName() string {
	return "CreateWalletReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletReplyValidationError{}

// Validate checks the field values on GetWalletInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletInfoRequestMultiError, or nil if none found.
func (m *GetWalletInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	if len(errors) > 0 {
		return GetWalletInfoRequestMultiError(errors)
	}

	return nil
}

// GetWalletInfoRequestMultiError is an error wrapping multiple validation
// errors returned by GetWalletInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletInfoRequestMultiError) AllErrors() []error { return m }

// GetWalletInfoRequestValidationError is the validation error returned by
// GetWalletInfoRequest.Validate if the designated constraints aren't met.
type GetWalletInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletInfoRequestValidationError) ErrorName() string {
	return "GetWalletInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletInfoRequestValidationError{}

// Validate checks the field values on GetWalletInfoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletInfoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletInfoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletInfoReplyMultiError, or nil if none found.
func (m *GetWalletInfoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletInfoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWalletInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletInfoReplyValidationError{
					field:  "WalletInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletInfoReplyValidationError{
					field:  "WalletInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWalletInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletInfoReplyValidationError{
				field:  "WalletInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletInfoReplyMultiError(errors)
	}

	return nil
}

// GetWalletInfoReplyMultiError is an error wrapping multiple validation errors
// returned by GetWalletInfoReply.ValidateAll() if the designated constraints
// aren't met.
type GetWalletInfoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletInfoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletInfoReplyMultiError) AllErrors() []error { return m }

// GetWalletInfoReplyValidationError is the validation error returned by
// GetWalletInfoReply.Validate if the designated constraints aren't met.
type GetWalletInfoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletInfoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletInfoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletInfoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletInfoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletInfoReplyValidationError) ErrorName() string {
	return "GetWalletInfoReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletInfoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletInfoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletInfoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletInfoReplyValidationError{}

// Validate checks the field values on GenerateMainGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMainGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMainGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateMainGroupRequestMultiError, or nil if none found.
func (m *GenerateMainGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMainGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	// no validation rules for NodeId

	if len(errors) > 0 {
		return GenerateMainGroupRequestMultiError(errors)
	}

	return nil
}

// GenerateMainGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GenerateMainGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateMainGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMainGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMainGroupRequestMultiError) AllErrors() []error { return m }

// GenerateMainGroupRequestValidationError is the validation error returned by
// GenerateMainGroupRequest.Validate if the designated constraints aren't met.
type GenerateMainGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMainGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMainGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMainGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMainGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMainGroupRequestValidationError) ErrorName() string {
	return "GenerateMainGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMainGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMainGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMainGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMainGroupRequestValidationError{}

// Validate checks the field values on GenerateMainGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMainGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMainGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateMainGroupReplyMultiError, or nil if none found.
func (m *GenerateMainGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMainGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	if len(errors) > 0 {
		return GenerateMainGroupReplyMultiError(errors)
	}

	return nil
}

// GenerateMainGroupReplyMultiError is an error wrapping multiple validation
// errors returned by GenerateMainGroupReply.ValidateAll() if the designated
// constraints aren't met.
type GenerateMainGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMainGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMainGroupReplyMultiError) AllErrors() []error { return m }

// GenerateMainGroupReplyValidationError is the validation error returned by
// GenerateMainGroupReply.Validate if the designated constraints aren't met.
type GenerateMainGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMainGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMainGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMainGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMainGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMainGroupReplyValidationError) ErrorName() string {
	return "GenerateMainGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMainGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMainGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMainGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMainGroupReplyValidationError{}

// Validate checks the field values on GenerateRecoveryGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateRecoveryGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateRecoveryGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateRecoveryGroupRequestMultiError, or nil if none found.
func (m *GenerateRecoveryGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateRecoveryGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	if len(errors) > 0 {
		return GenerateRecoveryGroupRequestMultiError(errors)
	}

	return nil
}

// GenerateRecoveryGroupRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateRecoveryGroupRequest.ValidateAll() if
// the designated constraints aren't met.
type GenerateRecoveryGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateRecoveryGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateRecoveryGroupRequestMultiError) AllErrors() []error { return m }

// GenerateRecoveryGroupRequestValidationError is the validation error returned
// by GenerateRecoveryGroupRequest.Validate if the designated constraints
// aren't met.
type GenerateRecoveryGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateRecoveryGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateRecoveryGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateRecoveryGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateRecoveryGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateRecoveryGroupRequestValidationError) ErrorName() string {
	return "GenerateRecoveryGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateRecoveryGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateRecoveryGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateRecoveryGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateRecoveryGroupRequestValidationError{}

// Validate checks the field values on GenerateRecoveryGroupReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateRecoveryGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateRecoveryGroupReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateRecoveryGroupReplyMultiError, or nil if none found.
func (m *GenerateRecoveryGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateRecoveryGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	if len(errors) > 0 {
		return GenerateRecoveryGroupReplyMultiError(errors)
	}

	return nil
}

// GenerateRecoveryGroupReplyMultiError is an error wrapping multiple
// validation errors returned by GenerateRecoveryGroupReply.ValidateAll() if
// the designated constraints aren't met.
type GenerateRecoveryGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateRecoveryGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateRecoveryGroupReplyMultiError) AllErrors() []error { return m }

// GenerateRecoveryGroupReplyValidationError is the validation error returned
// by GenerateRecoveryGroupReply.Validate if the designated constraints aren't met.
type GenerateRecoveryGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateRecoveryGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateRecoveryGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateRecoveryGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateRecoveryGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateRecoveryGroupReplyValidationError) ErrorName() string {
	return "GenerateRecoveryGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateRecoveryGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateRecoveryGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateRecoveryGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateRecoveryGroupReplyValidationError{}

// Validate checks the field values on RecoverMainGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecoverMainGroupRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecoverMainGroupRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecoverMainGroupRequestMultiError, or nil if none found.
func (m *RecoverMainGroupRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RecoverMainGroupRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	// no validation rules for NodeId

	// no validation rules for SourceGroupId

	if len(errors) > 0 {
		return RecoverMainGroupRequestMultiError(errors)
	}

	return nil
}

// RecoverMainGroupRequestMultiError is an error wrapping multiple validation
// errors returned by RecoverMainGroupRequest.ValidateAll() if the designated
// constraints aren't met.
type RecoverMainGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecoverMainGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecoverMainGroupRequestMultiError) AllErrors() []error { return m }

// RecoverMainGroupRequestValidationError is the validation error returned by
// RecoverMainGroupRequest.Validate if the designated constraints aren't met.
type RecoverMainGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecoverMainGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecoverMainGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecoverMainGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecoverMainGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecoverMainGroupRequestValidationError) ErrorName() string {
	return "RecoverMainGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RecoverMainGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecoverMainGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecoverMainGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecoverMainGroupRequestValidationError{}

// Validate checks the field values on RecoverMainGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RecoverMainGroupReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecoverMainGroupReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecoverMainGroupReplyMultiError, or nil if none found.
func (m *RecoverMainGroupReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RecoverMainGroupReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	if len(errors) > 0 {
		return RecoverMainGroupReplyMultiError(errors)
	}

	return nil
}

// RecoverMainGroupReplyMultiError is an error wrapping multiple validation
// errors returned by RecoverMainGroupReply.ValidateAll() if the designated
// constraints aren't met.
type RecoverMainGroupReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecoverMainGroupReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecoverMainGroupReplyMultiError) AllErrors() []error { return m }

// RecoverMainGroupReplyValidationError is the validation error returned by
// RecoverMainGroupReply.Validate if the designated constraints aren't met.
type RecoverMainGroupReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecoverMainGroupReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecoverMainGroupReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecoverMainGroupReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecoverMainGroupReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecoverMainGroupReplyValidationError) ErrorName() string {
	return "RecoverMainGroupReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RecoverMainGroupReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecoverMainGroupReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecoverMainGroupReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecoverMainGroupReplyValidationError{}

// Validate checks the field values on ListTssRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTssRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTssRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTssRequestRequestMultiError, or nil if none found.
func (m *ListTssRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTssRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	// no validation rules for NodeId

	// no validation rules for Status

	if len(errors) > 0 {
		return ListTssRequestRequestMultiError(errors)
	}

	return nil
}

// ListTssRequestRequestMultiError is an error wrapping multiple validation
// errors returned by ListTssRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTssRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTssRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTssRequestRequestMultiError) AllErrors() []error { return m }

// ListTssRequestRequestValidationError is the validation error returned by
// ListTssRequestRequest.Validate if the designated constraints aren't met.
type ListTssRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTssRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTssRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTssRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTssRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTssRequestRequestValidationError) ErrorName() string {
	return "ListTssRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTssRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTssRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTssRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTssRequestRequestValidationError{}

// Validate checks the field values on ListTssRequestReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTssRequestReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTssRequestReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTssRequestReplyMultiError, or nil if none found.
func (m *ListTssRequestReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTssRequestReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTssRequests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTssRequestReplyValidationError{
						field:  fmt.Sprintf("TssRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTssRequestReplyValidationError{
						field:  fmt.Sprintf("TssRequests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTssRequestReplyValidationError{
					field:  fmt.Sprintf("TssRequests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTssRequestReplyMultiError(errors)
	}

	return nil
}

// ListTssRequestReplyMultiError is an error wrapping multiple validation
// errors returned by ListTssRequestReply.ValidateAll() if the designated
// constraints aren't met.
type ListTssRequestReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTssRequestReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTssRequestReplyMultiError) AllErrors() []error { return m }

// ListTssRequestReplyValidationError is the validation error returned by
// ListTssRequestReply.Validate if the designated constraints aren't met.
type ListTssRequestReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTssRequestReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTssRequestReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTssRequestReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTssRequestReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTssRequestReplyValidationError) ErrorName() string {
	return "ListTssRequestReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListTssRequestReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTssRequestReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTssRequestReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTssRequestReplyValidationError{}

// Validate checks the field values on GetTssRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTssRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTssRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTssRequestRequestMultiError, or nil if none found.
func (m *GetTssRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTssRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	// no validation rules for VaultId

	if len(errors) > 0 {
		return GetTssRequestRequestMultiError(errors)
	}

	return nil
}

// GetTssRequestRequestMultiError is an error wrapping multiple validation
// errors returned by GetTssRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTssRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTssRequestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTssRequestRequestMultiError) AllErrors() []error { return m }

// GetTssRequestRequestValidationError is the validation error returned by
// GetTssRequestRequest.Validate if the designated constraints aren't met.
type GetTssRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTssRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTssRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTssRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTssRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTssRequestRequestValidationError) ErrorName() string {
	return "GetTssRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTssRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTssRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTssRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTssRequestRequestValidationError{}

// Validate checks the field values on GetTssRequestReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTssRequestReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTssRequestReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTssRequestReplyMultiError, or nil if none found.
func (m *GetTssRequestReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTssRequestReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTssRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTssRequestReplyValidationError{
					field:  "TssRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTssRequestReplyValidationError{
					field:  "TssRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTssRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTssRequestReplyValidationError{
				field:  "TssRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTssRequestReplyMultiError(errors)
	}

	return nil
}

// GetTssRequestReplyMultiError is an error wrapping multiple validation errors
// returned by GetTssRequestReply.ValidateAll() if the designated constraints
// aren't met.
type GetTssRequestReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTssRequestReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTssRequestReplyMultiError) AllErrors() []error { return m }

// GetTssRequestReplyValidationError is the validation error returned by
// GetTssRequestReply.Validate if the designated constraints aren't met.
type GetTssRequestReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTssRequestReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTssRequestReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTssRequestReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTssRequestReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTssRequestReplyValidationError) ErrorName() string {
	return "GetTssRequestReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTssRequestReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTssRequestReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTssRequestReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTssRequestReplyValidationError{}

// Validate checks the field values on DisasterRecoveryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DisasterRecoveryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisasterRecoveryRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisasterRecoveryRequestMultiError, or nil if none found.
func (m *DisasterRecoveryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisasterRecoveryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for VaultId

	if len(errors) > 0 {
		return DisasterRecoveryRequestMultiError(errors)
	}

	return nil
}

// DisasterRecoveryRequestMultiError is an error wrapping multiple validation
// errors returned by DisasterRecoveryRequest.ValidateAll() if the designated
// constraints aren't met.
type DisasterRecoveryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisasterRecoveryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisasterRecoveryRequestMultiError) AllErrors() []error { return m }

// DisasterRecoveryRequestValidationError is the validation error returned by
// DisasterRecoveryRequest.Validate if the designated constraints aren't met.
type DisasterRecoveryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisasterRecoveryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisasterRecoveryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisasterRecoveryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisasterRecoveryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisasterRecoveryRequestValidationError) ErrorName() string {
	return "DisasterRecoveryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisasterRecoveryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisasterRecoveryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisasterRecoveryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisasterRecoveryRequestValidationError{}

// Validate checks the field values on DisasterRecoveryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DisasterRecoveryReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisasterRecoveryReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisasterRecoveryReplyMultiError, or nil if none found.
func (m *DisasterRecoveryReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DisasterRecoveryReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVault()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DisasterRecoveryReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DisasterRecoveryReplyValidationError{
					field:  "Vault",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVault()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DisasterRecoveryReplyValidationError{
				field:  "Vault",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWallet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DisasterRecoveryReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DisasterRecoveryReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWallet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DisasterRecoveryReplyValidationError{
				field:  "Wallet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DisasterRecoveryReplyValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DisasterRecoveryReplyValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DisasterRecoveryReplyValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DisasterRecoveryReplyMultiError(errors)
	}

	return nil
}

// DisasterRecoveryReplyMultiError is an error wrapping multiple validation
// errors returned by DisasterRecoveryReply.ValidateAll() if the designated
// constraints aren't met.
type DisasterRecoveryReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisasterRecoveryReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisasterRecoveryReplyMultiError) AllErrors() []error { return m }

// DisasterRecoveryReplyValidationError is the validation error returned by
// DisasterRecoveryReply.Validate if the designated constraints aren't met.
type DisasterRecoveryReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisasterRecoveryReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisasterRecoveryReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisasterRecoveryReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisasterRecoveryReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisasterRecoveryReplyValidationError) ErrorName() string {
	return "DisasterRecoveryReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DisasterRecoveryReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisasterRecoveryReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisasterRecoveryReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisasterRecoveryReplyValidationError{}

// Validate checks the field values on GetTssRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTssRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTssRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTssRequestMultiError, or
// nil if none found.
func (m *GetTssRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTssRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	if len(errors) > 0 {
		return GetTssRequestMultiError(errors)
	}

	return nil
}

// GetTssRequestMultiError is an error wrapping multiple validation errors
// returned by GetTssRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTssRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTssRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTssRequestMultiError) AllErrors() []error { return m }

// GetTssRequestValidationError is the validation error returned by
// GetTssRequest.Validate if the designated constraints aren't met.
type GetTssRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTssRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTssRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTssRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTssRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTssRequestValidationError) ErrorName() string { return "GetTssRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTssRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTssRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTssRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTssRequestValidationError{}

// Validate checks the field values on GetTssReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTssReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTssReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTssReplyMultiError, or
// nil if none found.
func (m *GetTssReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTssReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTssRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTssReplyValidationError{
					field:  "TssRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTssReplyValidationError{
					field:  "TssRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTssRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTssReplyValidationError{
				field:  "TssRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTssReplyMultiError(errors)
	}

	return nil
}

// GetTssReplyMultiError is an error wrapping multiple validation errors
// returned by GetTssReply.ValidateAll() if the designated constraints aren't met.
type GetTssReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTssReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTssReplyMultiError) AllErrors() []error { return m }

// GetTssReplyValidationError is the validation error returned by
// GetTssReply.Validate if the designated constraints aren't met.
type GetTssReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTssReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTssReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTssReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTssReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTssReplyValidationError) ErrorName() string { return "GetTssReplyValidationError" }

// Error satisfies the builtin error interface
func (e GetTssReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTssReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTssReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTssReplyValidationError{}

// Validate checks the field values on EstimateTransactionFeeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EstimateTransactionFeeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EstimateTransactionFeeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EstimateTransactionFeeRequestMultiError, or nil if none found.
func (m *EstimateTransactionFeeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EstimateTransactionFeeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for TokenId

	// no validation rules for Amount

	// no validation rules for Type

	// no validation rules for WalletId

	if len(errors) > 0 {
		return EstimateTransactionFeeRequestMultiError(errors)
	}

	return nil
}

// EstimateTransactionFeeRequestMultiError is an error wrapping multiple
// validation errors returned by EstimateTransactionFeeRequest.ValidateAll()
// if the designated constraints aren't met.
type EstimateTransactionFeeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EstimateTransactionFeeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EstimateTransactionFeeRequestMultiError) AllErrors() []error { return m }

// EstimateTransactionFeeRequestValidationError is the validation error
// returned by EstimateTransactionFeeRequest.Validate if the designated
// constraints aren't met.
type EstimateTransactionFeeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EstimateTransactionFeeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EstimateTransactionFeeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EstimateTransactionFeeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EstimateTransactionFeeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EstimateTransactionFeeRequestValidationError) ErrorName() string {
	return "EstimateTransactionFeeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EstimateTransactionFeeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEstimateTransactionFeeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EstimateTransactionFeeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EstimateTransactionFeeRequestValidationError{}

// Validate checks the field values on EstimateTransactionFeeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EstimateTransactionFeeReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EstimateTransactionFeeReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EstimateTransactionFeeReplyMultiError, or nil if none found.
func (m *EstimateTransactionFeeReply) ValidateAll() error {
	return m.validate(true)
}

func (m *EstimateTransactionFeeReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSlow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Slow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Slow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSlow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EstimateTransactionFeeReplyValidationError{
				field:  "Slow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRecommend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Recommend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Recommend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecommend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EstimateTransactionFeeReplyValidationError{
				field:  "Recommend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFast()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Fast",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EstimateTransactionFeeReplyValidationError{
					field:  "Fast",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFast()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EstimateTransactionFeeReplyValidationError{
				field:  "Fast",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EstimateTransactionFeeReplyMultiError(errors)
	}

	return nil
}

// EstimateTransactionFeeReplyMultiError is an error wrapping multiple
// validation errors returned by EstimateTransactionFeeReply.ValidateAll() if
// the designated constraints aren't met.
type EstimateTransactionFeeReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EstimateTransactionFeeReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EstimateTransactionFeeReplyMultiError) AllErrors() []error { return m }

// EstimateTransactionFeeReplyValidationError is the validation error returned
// by EstimateTransactionFeeReply.Validate if the designated constraints
// aren't met.
type EstimateTransactionFeeReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EstimateTransactionFeeReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EstimateTransactionFeeReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EstimateTransactionFeeReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EstimateTransactionFeeReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EstimateTransactionFeeReplyValidationError) ErrorName() string {
	return "EstimateTransactionFeeReplyValidationError"
}

// Error satisfies the builtin error interface
func (e EstimateTransactionFeeReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEstimateTransactionFeeReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EstimateTransactionFeeReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EstimateTransactionFeeReplyValidationError{}

// Validate checks the field values on CreateTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionRequestMultiError, or nil if none found.
func (m *CreateTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Amount

	// no validation rules for TokenId

	// no validation rules for Chain

	// no validation rules for Type

	if m.GetFee() == nil {
		err := CreateTransactionRequestValidationError{
			field:  "Fee",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetFee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionRequestValidationError{
					field:  "Fee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionRequestValidationError{
					field:  "Fee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionRequestValidationError{
				field:  "Fee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for WalletId

	if len(errors) > 0 {
		return CreateTransactionRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionRequestMultiError) AllErrors() []error { return m }

// CreateTransactionRequestValidationError is the validation error returned by
// CreateTransactionRequest.Validate if the designated constraints aren't met.
type CreateTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionRequestValidationError) ErrorName() string {
	return "CreateTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionRequestValidationError{}

// Validate checks the field values on CreateTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionReplyMultiError, or nil if none found.
func (m *CreateTransactionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return CreateTransactionReplyMultiError(errors)
	}

	return nil
}

// CreateTransactionReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTransactionReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionReplyMultiError) AllErrors() []error { return m }

// CreateTransactionReplyValidationError is the validation error returned by
// CreateTransactionReply.Validate if the designated constraints aren't met.
type CreateTransactionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionReplyValidationError) ErrorName() string {
	return "CreateTransactionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionReplyValidationError{}

// Validate checks the field values on AddWalletAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddWalletAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddWalletAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddWalletAddressRequestMultiError, or nil if none found.
func (m *AddWalletAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddWalletAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for ChainId

	if len(errors) > 0 {
		return AddWalletAddressRequestMultiError(errors)
	}

	return nil
}

// AddWalletAddressRequestMultiError is an error wrapping multiple validation
// errors returned by AddWalletAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type AddWalletAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddWalletAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddWalletAddressRequestMultiError) AllErrors() []error { return m }

// AddWalletAddressRequestValidationError is the validation error returned by
// AddWalletAddressRequest.Validate if the designated constraints aren't met.
type AddWalletAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddWalletAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddWalletAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddWalletAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddWalletAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddWalletAddressRequestValidationError) ErrorName() string {
	return "AddWalletAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddWalletAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddWalletAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddWalletAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddWalletAddressRequestValidationError{}

// Validate checks the field values on AddWalletAddressReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddWalletAddressReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddWalletAddressReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddWalletAddressReplyMultiError, or nil if none found.
func (m *AddWalletAddressReply) ValidateAll() error {
	return m.validate(true)
}

func (m *AddWalletAddressReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddWalletAddressReplyValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddWalletAddressReplyValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddWalletAddressReplyValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddWalletAddressReplyMultiError(errors)
	}

	return nil
}

// AddWalletAddressReplyMultiError is an error wrapping multiple validation
// errors returned by AddWalletAddressReply.ValidateAll() if the designated
// constraints aren't met.
type AddWalletAddressReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddWalletAddressReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddWalletAddressReplyMultiError) AllErrors() []error { return m }

// AddWalletAddressReplyValidationError is the validation error returned by
// AddWalletAddressReply.Validate if the designated constraints aren't met.
type AddWalletAddressReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddWalletAddressReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddWalletAddressReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddWalletAddressReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddWalletAddressReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddWalletAddressReplyValidationError) ErrorName() string {
	return "AddWalletAddressReplyValidationError"
}

// Error satisfies the builtin error interface
func (e AddWalletAddressReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddWalletAddressReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddWalletAddressReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddWalletAddressReplyValidationError{}

// Validate checks the field values on ListWalletTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletTokenRequestMultiError, or nil if none found.
func (m *ListWalletTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	if len(errors) > 0 {
		return ListWalletTokenRequestMultiError(errors)
	}

	return nil
}

// ListWalletTokenRequestMultiError is an error wrapping multiple validation
// errors returned by ListWalletTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type ListWalletTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTokenRequestMultiError) AllErrors() []error { return m }

// ListWalletTokenRequestValidationError is the validation error returned by
// ListWalletTokenRequest.Validate if the designated constraints aren't met.
type ListWalletTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTokenRequestValidationError) ErrorName() string {
	return "ListWalletTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTokenRequestValidationError{}

// Validate checks the field values on ListWalletTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletTokenReplyMultiError, or nil if none found.
func (m *ListWalletTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletTokenReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletTokenReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletTokenReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletTokenReplyMultiError(errors)
	}

	return nil
}

// ListWalletTokenReplyMultiError is an error wrapping multiple validation
// errors returned by ListWalletTokenReply.ValidateAll() if the designated
// constraints aren't met.
type ListWalletTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTokenReplyMultiError) AllErrors() []error { return m }

// ListWalletTokenReplyValidationError is the validation error returned by
// ListWalletTokenReply.Validate if the designated constraints aren't met.
type ListWalletTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTokenReplyValidationError) ErrorName() string {
	return "ListWalletTokenReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTokenReplyValidationError{}

// Validate checks the field values on GetWalletTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletTokenRequestMultiError, or nil if none found.
func (m *GetWalletTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TokenId

	if len(errors) > 0 {
		return GetWalletTokenRequestMultiError(errors)
	}

	return nil
}

// GetWalletTokenRequestMultiError is an error wrapping multiple validation
// errors returned by GetWalletTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type GetWalletTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletTokenRequestMultiError) AllErrors() []error { return m }

// GetWalletTokenRequestValidationError is the validation error returned by
// GetWalletTokenRequest.Validate if the designated constraints aren't met.
type GetWalletTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletTokenRequestValidationError) ErrorName() string {
	return "GetWalletTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletTokenRequestValidationError{}

// Validate checks the field values on GetWalletTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetWalletTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetWalletTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetWalletTokenReplyMultiError, or nil if none found.
func (m *GetWalletTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetWalletTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWallet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletTokenReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletTokenReplyValidationError{
					field:  "Wallet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWallet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletTokenReplyValidationError{
				field:  "Wallet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenAddresses()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetWalletTokenReplyValidationError{
					field:  "TokenAddresses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetWalletTokenReplyValidationError{
					field:  "TokenAddresses",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenAddresses()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetWalletTokenReplyValidationError{
				field:  "TokenAddresses",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetWalletTokenReplyMultiError(errors)
	}

	return nil
}

// GetWalletTokenReplyMultiError is an error wrapping multiple validation
// errors returned by GetWalletTokenReply.ValidateAll() if the designated
// constraints aren't met.
type GetWalletTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletTokenReplyMultiError) AllErrors() []error { return m }

// GetWalletTokenReplyValidationError is the validation error returned by
// GetWalletTokenReply.Validate if the designated constraints aren't met.
type GetWalletTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletTokenReplyValidationError) ErrorName() string {
	return "GetWalletTokenReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletTokenReplyValidationError{}

// Validate checks the field values on GetTokenBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTokenBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenBalanceRequestMultiError, or nil if none found.
func (m *GetTokenBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TokenId

	// no validation rules for Address

	if len(errors) > 0 {
		return GetTokenBalanceRequestMultiError(errors)
	}

	return nil
}

// GetTokenBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetTokenBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTokenBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenBalanceRequestMultiError) AllErrors() []error { return m }

// GetTokenBalanceRequestValidationError is the validation error returned by
// GetTokenBalanceRequest.Validate if the designated constraints aren't met.
type GetTokenBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenBalanceRequestValidationError) ErrorName() string {
	return "GetTokenBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTokenBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenBalanceRequestValidationError{}

// Validate checks the field values on GetTokenBalanceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTokenBalanceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTokenBalanceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTokenBalanceReplyMultiError, or nil if none found.
func (m *GetTokenBalanceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTokenBalanceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTokenBalance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTokenBalanceReplyValidationError{
					field:  "TokenBalance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTokenBalanceReplyValidationError{
					field:  "TokenBalance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenBalance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTokenBalanceReplyValidationError{
				field:  "TokenBalance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTokenBalanceReplyMultiError(errors)
	}

	return nil
}

// GetTokenBalanceReplyMultiError is an error wrapping multiple validation
// errors returned by GetTokenBalanceReply.ValidateAll() if the designated
// constraints aren't met.
type GetTokenBalanceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTokenBalanceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTokenBalanceReplyMultiError) AllErrors() []error { return m }

// GetTokenBalanceReplyValidationError is the validation error returned by
// GetTokenBalanceReply.Validate if the designated constraints aren't met.
type GetTokenBalanceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTokenBalanceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTokenBalanceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTokenBalanceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTokenBalanceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTokenBalanceReplyValidationError) ErrorName() string {
	return "GetTokenBalanceReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTokenBalanceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTokenBalanceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTokenBalanceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTokenBalanceReplyValidationError{}

// Validate checks the field values on ListTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionRequestMultiError, or nil if none found.
func (m *ListTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TokenId

	// no validation rules for TransactionType

	if len(errors) > 0 {
		return ListTransactionRequestMultiError(errors)
	}

	return nil
}

// ListTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionRequestMultiError) AllErrors() []error { return m }

// ListTransactionRequestValidationError is the validation error returned by
// ListTransactionRequest.Validate if the designated constraints aren't met.
type ListTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionRequestValidationError) ErrorName() string {
	return "ListTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionRequestValidationError{}

// Validate checks the field values on ListTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransactionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransactionReplyMultiError, or nil if none found.
func (m *ListTransactionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransactionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransactionReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransactionReplyValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransactionReplyValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransactionReplyMultiError(errors)
	}

	return nil
}

// ListTransactionReplyMultiError is an error wrapping multiple validation
// errors returned by ListTransactionReply.ValidateAll() if the designated
// constraints aren't met.
type ListTransactionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionReplyMultiError) AllErrors() []error { return m }

// ListTransactionReplyValidationError is the validation error returned by
// ListTransactionReply.Validate if the designated constraints aren't met.
type ListTransactionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionReplyValidationError) ErrorName() string {
	return "ListTransactionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionReplyValidationError{}

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionRequestMultiError, or nil if none found.
func (m *GetTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return GetTransactionRequestMultiError(errors)
	}

	return nil
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error { return m }

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

// Validate checks the field values on GetTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionReplyMultiError, or nil if none found.
func (m *GetTransactionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionReplyValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionReplyValidationError{
					field:  "Transaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionReplyValidationError{
				field:  "Transaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransactionReplyMultiError(errors)
	}

	return nil
}

// GetTransactionReplyMultiError is an error wrapping multiple validation
// errors returned by GetTransactionReply.ValidateAll() if the designated
// constraints aren't met.
type GetTransactionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionReplyMultiError) AllErrors() []error { return m }

// GetTransactionReplyValidationError is the validation error returned by
// GetTransactionReply.Validate if the designated constraints aren't met.
type GetTransactionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionReplyValidationError) ErrorName() string {
	return "GetTransactionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionReplyValidationError{}

// Validate checks the field values on CoboTransaction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransactionMultiError, or nil if none found.
func (m *CoboTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Type

	// no validation rules for Status

	// no validation rules for TokenId

	// no validation rules for ChainId

	// no validation rules for FailedReason

	// no validation rules for RequestId

	// no validation rules for SubStatus

	// no validation rules for ConfirmedNum

	// no validation rules for ConfirmingThreshold

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CoboTransactionValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CoboTransactionValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRawTxInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "RawTxInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "RawTxInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRawTxInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CoboTransactionValidationError{
				field:  "RawTxInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Fee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "Fee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CoboTransactionValidationError{
				field:  "Fee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TransactionHash

	if all {
		switch v := interface{}(m.GetBlockInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "BlockInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CoboTransactionValidationError{
					field:  "BlockInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CoboTransactionValidationError{
				field:  "BlockInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if len(errors) > 0 {
		return CoboTransactionMultiError(errors)
	}

	return nil
}

// CoboTransactionMultiError is an error wrapping multiple validation errors
// returned by CoboTransaction.ValidateAll() if the designated constraints
// aren't met.
type CoboTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransactionMultiError) AllErrors() []error { return m }

// CoboTransactionValidationError is the validation error returned by
// CoboTransaction.Validate if the designated constraints aren't met.
type CoboTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransactionValidationError) ErrorName() string { return "CoboTransactionValidationError" }

// Error satisfies the builtin error interface
func (e CoboTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransactionValidationError{}

// Validate checks the field values on TransactionWebhookRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionWebhookRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionWebhookRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionWebhookRequestMultiError, or nil if none found.
func (m *TransactionWebhookRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionWebhookRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for Url

	// no validation rules for CreatedTimestamp

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionWebhookRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionWebhookRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionWebhookRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionWebhookRequestMultiError(errors)
	}

	return nil
}

// TransactionWebhookRequestMultiError is an error wrapping multiple validation
// errors returned by TransactionWebhookRequest.ValidateAll() if the
// designated constraints aren't met.
type TransactionWebhookRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionWebhookRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionWebhookRequestMultiError) AllErrors() []error { return m }

// TransactionWebhookRequestValidationError is the validation error returned by
// TransactionWebhookRequest.Validate if the designated constraints aren't met.
type TransactionWebhookRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionWebhookRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionWebhookRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionWebhookRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionWebhookRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionWebhookRequestValidationError) ErrorName() string {
	return "TransactionWebhookRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionWebhookRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionWebhookRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionWebhookRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionWebhookRequestValidationError{}

// Validate checks the field values on TransactionWebhookReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionWebhookReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionWebhookReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionWebhookReplyMultiError, or nil if none found.
func (m *TransactionWebhookReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionWebhookReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TransactionWebhookReplyMultiError(errors)
	}

	return nil
}

// TransactionWebhookReplyMultiError is an error wrapping multiple validation
// errors returned by TransactionWebhookReply.ValidateAll() if the designated
// constraints aren't met.
type TransactionWebhookReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionWebhookReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionWebhookReplyMultiError) AllErrors() []error { return m }

// TransactionWebhookReplyValidationError is the validation error returned by
// TransactionWebhookReply.Validate if the designated constraints aren't met.
type TransactionWebhookReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionWebhookReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionWebhookReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionWebhookReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionWebhookReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionWebhookReplyValidationError) ErrorName() string {
	return "TransactionWebhookReplyValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionWebhookReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionWebhookReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionWebhookReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionWebhookReplyValidationError{}

// Validate checks the field values on CoboCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboCallbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboCallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboCallbackRequestMultiError, or nil if none found.
func (m *CoboCallbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboCallbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Type

	if len(errors) > 0 {
		return CoboCallbackRequestMultiError(errors)
	}

	return nil
}

// CoboCallbackRequestMultiError is an error wrapping multiple validation
// errors returned by CoboCallbackRequest.ValidateAll() if the designated
// constraints aren't met.
type CoboCallbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboCallbackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboCallbackRequestMultiError) AllErrors() []error { return m }

// CoboCallbackRequestValidationError is the validation error returned by
// CoboCallbackRequest.Validate if the designated constraints aren't met.
type CoboCallbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboCallbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboCallbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboCallbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboCallbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboCallbackRequestValidationError) ErrorName() string {
	return "CoboCallbackRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CoboCallbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboCallbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboCallbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboCallbackRequestValidationError{}

// Validate checks the field values on CoboCallbackReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CoboCallbackReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboCallbackReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboCallbackReplyMultiError, or nil if none found.
func (m *CoboCallbackReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboCallbackReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CoboCallbackReplyMultiError(errors)
	}

	return nil
}

// CoboCallbackReplyMultiError is an error wrapping multiple validation errors
// returned by CoboCallbackReply.ValidateAll() if the designated constraints
// aren't met.
type CoboCallbackReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboCallbackReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboCallbackReplyMultiError) AllErrors() []error { return m }

// CoboCallbackReplyValidationError is the validation error returned by
// CoboCallbackReply.Validate if the designated constraints aren't met.
type CoboCallbackReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboCallbackReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboCallbackReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboCallbackReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboCallbackReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboCallbackReplyValidationError) ErrorName() string {
	return "CoboCallbackReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CoboCallbackReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboCallbackReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboCallbackReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboCallbackReplyValidationError{}

// Validate checks the field values on CoboTssRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CoboTssRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTssRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CoboTssRequestMultiError,
// or nil if none found.
func (m *CoboTssRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTssRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	// no validation rules for Status

	if len(errors) > 0 {
		return CoboTssRequestMultiError(errors)
	}

	return nil
}

// CoboTssRequestMultiError is an error wrapping multiple validation errors
// returned by CoboTssRequest.ValidateAll() if the designated constraints
// aren't met.
type CoboTssRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTssRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTssRequestMultiError) AllErrors() []error { return m }

// CoboTssRequestValidationError is the validation error returned by
// CoboTssRequest.Validate if the designated constraints aren't met.
type CoboTssRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTssRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTssRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTssRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTssRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTssRequestValidationError) ErrorName() string { return "CoboTssRequestValidationError" }

// Error satisfies the builtin error interface
func (e CoboTssRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTssRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTssRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTssRequestValidationError{}

// Validate checks the field values on TssRequestWebhookRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TssRequestWebhookRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TssRequestWebhookRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TssRequestWebhookRequestMultiError, or nil if none found.
func (m *TssRequestWebhookRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TssRequestWebhookRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for Url

	// no validation rules for CreatedTimestamp

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TssRequestWebhookRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TssRequestWebhookRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TssRequestWebhookRequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TssRequestWebhookRequestMultiError(errors)
	}

	return nil
}

// TssRequestWebhookRequestMultiError is an error wrapping multiple validation
// errors returned by TssRequestWebhookRequest.ValidateAll() if the designated
// constraints aren't met.
type TssRequestWebhookRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TssRequestWebhookRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TssRequestWebhookRequestMultiError) AllErrors() []error { return m }

// TssRequestWebhookRequestValidationError is the validation error returned by
// TssRequestWebhookRequest.Validate if the designated constraints aren't met.
type TssRequestWebhookRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TssRequestWebhookRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TssRequestWebhookRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TssRequestWebhookRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TssRequestWebhookRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TssRequestWebhookRequestValidationError) ErrorName() string {
	return "TssRequestWebhookRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TssRequestWebhookRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTssRequestWebhookRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TssRequestWebhookRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TssRequestWebhookRequestValidationError{}

// Validate checks the field values on TssRequestWebhookReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TssRequestWebhookReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TssRequestWebhookReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TssRequestWebhookReplyMultiError, or nil if none found.
func (m *TssRequestWebhookReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TssRequestWebhookReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TssRequestWebhookReplyMultiError(errors)
	}

	return nil
}

// TssRequestWebhookReplyMultiError is an error wrapping multiple validation
// errors returned by TssRequestWebhookReply.ValidateAll() if the designated
// constraints aren't met.
type TssRequestWebhookReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TssRequestWebhookReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TssRequestWebhookReplyMultiError) AllErrors() []error { return m }

// TssRequestWebhookReplyValidationError is the validation error returned by
// TssRequestWebhookReply.Validate if the designated constraints aren't met.
type TssRequestWebhookReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TssRequestWebhookReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TssRequestWebhookReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TssRequestWebhookReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TssRequestWebhookReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TssRequestWebhookReplyValidationError) ErrorName() string {
	return "TssRequestWebhookReplyValidationError"
}

// Error satisfies the builtin error interface
func (e TssRequestWebhookReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTssRequestWebhookReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TssRequestWebhookReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TssRequestWebhookReplyValidationError{}

// Validate checks the field values on TssRequestReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TssRequestReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TssRequestReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TssRequestReportRequestMultiError, or nil if none found.
func (m *TssRequestReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TssRequestReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TssRequestId

	// no validation rules for Action

	if len(errors) > 0 {
		return TssRequestReportRequestMultiError(errors)
	}

	return nil
}

// TssRequestReportRequestMultiError is an error wrapping multiple validation
// errors returned by TssRequestReportRequest.ValidateAll() if the designated
// constraints aren't met.
type TssRequestReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TssRequestReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TssRequestReportRequestMultiError) AllErrors() []error { return m }

// TssRequestReportRequestValidationError is the validation error returned by
// TssRequestReportRequest.Validate if the designated constraints aren't met.
type TssRequestReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TssRequestReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TssRequestReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TssRequestReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TssRequestReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TssRequestReportRequestValidationError) ErrorName() string {
	return "TssRequestReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TssRequestReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTssRequestReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TssRequestReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TssRequestReportRequestValidationError{}

// Validate checks the field values on TssRequestReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TssRequestReportReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TssRequestReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TssRequestReportReplyMultiError, or nil if none found.
func (m *TssRequestReportReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TssRequestReportReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TssRequestReportReplyMultiError(errors)
	}

	return nil
}

// TssRequestReportReplyMultiError is an error wrapping multiple validation
// errors returned by TssRequestReportReply.ValidateAll() if the designated
// constraints aren't met.
type TssRequestReportReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TssRequestReportReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TssRequestReportReplyMultiError) AllErrors() []error { return m }

// TssRequestReportReplyValidationError is the validation error returned by
// TssRequestReportReply.Validate if the designated constraints aren't met.
type TssRequestReportReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TssRequestReportReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TssRequestReportReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TssRequestReportReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TssRequestReportReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TssRequestReportReplyValidationError) ErrorName() string {
	return "TssRequestReportReplyValidationError"
}

// Error satisfies the builtin error interface
func (e TssRequestReportReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTssRequestReportReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TssRequestReportReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TssRequestReportReplyValidationError{}

// Validate checks the field values on TransactionReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionReportRequestMultiError, or nil if none found.
func (m *TransactionReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for Action

	if len(errors) > 0 {
		return TransactionReportRequestMultiError(errors)
	}

	return nil
}

// TransactionReportRequestMultiError is an error wrapping multiple validation
// errors returned by TransactionReportRequest.ValidateAll() if the designated
// constraints aren't met.
type TransactionReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionReportRequestMultiError) AllErrors() []error { return m }

// TransactionReportRequestValidationError is the validation error returned by
// TransactionReportRequest.Validate if the designated constraints aren't met.
type TransactionReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionReportRequestValidationError) ErrorName() string {
	return "TransactionReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionReportRequestValidationError{}

// Validate checks the field values on TransactionReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionReportReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionReportReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionReportReplyMultiError, or nil if none found.
func (m *TransactionReportReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionReportReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TransactionReportReplyMultiError(errors)
	}

	return nil
}

// TransactionReportReplyMultiError is an error wrapping multiple validation
// errors returned by TransactionReportReply.ValidateAll() if the designated
// constraints aren't met.
type TransactionReportReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionReportReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionReportReplyMultiError) AllErrors() []error { return m }

// TransactionReportReplyValidationError is the validation error returned by
// TransactionReportReply.Validate if the designated constraints aren't met.
type TransactionReportReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionReportReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionReportReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionReportReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionReportReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionReportReplyValidationError) ErrorName() string {
	return "TransactionReportReplyValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionReportReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionReportReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionReportReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionReportReplyValidationError{}

// Validate checks the field values on CoboTransaction_Fee with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_Fee) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_Fee with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_FeeMultiError, or nil if none found.
func (m *CoboTransaction_Fee) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_Fee) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FeeType

	// no validation rules for TokenId

	// no validation rules for FeeUsed

	// no validation rules for GasUsed

	// no validation rules for EffectiveGasPrice

	// no validation rules for MaxFeePerGas

	// no validation rules for MaxPriorityFeePerGas

	// no validation rules for GasLimit

	// no validation rules for FeeRate

	// no validation rules for FeeAmount

	if len(errors) > 0 {
		return CoboTransaction_FeeMultiError(errors)
	}

	return nil
}

// CoboTransaction_FeeMultiError is an error wrapping multiple validation
// errors returned by CoboTransaction_Fee.ValidateAll() if the designated
// constraints aren't met.
type CoboTransaction_FeeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_FeeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_FeeMultiError) AllErrors() []error { return m }

// CoboTransaction_FeeValidationError is the validation error returned by
// CoboTransaction_Fee.Validate if the designated constraints aren't met.
type CoboTransaction_FeeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_FeeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_FeeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_FeeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_FeeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_FeeValidationError) ErrorName() string {
	return "CoboTransaction_FeeValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_FeeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_Fee.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_FeeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_FeeValidationError{}

// Validate checks the field values on CoboTransaction_BlockInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_BlockInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_BlockInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_BlockInfoMultiError, or nil if none found.
func (m *CoboTransaction_BlockInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_BlockInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlockNumber

	// no validation rules for BlockTime

	// no validation rules for BlockHash

	if len(errors) > 0 {
		return CoboTransaction_BlockInfoMultiError(errors)
	}

	return nil
}

// CoboTransaction_BlockInfoMultiError is an error wrapping multiple validation
// errors returned by CoboTransaction_BlockInfo.ValidateAll() if the
// designated constraints aren't met.
type CoboTransaction_BlockInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_BlockInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_BlockInfoMultiError) AllErrors() []error { return m }

// CoboTransaction_BlockInfoValidationError is the validation error returned by
// CoboTransaction_BlockInfo.Validate if the designated constraints aren't met.
type CoboTransaction_BlockInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_BlockInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_BlockInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_BlockInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_BlockInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_BlockInfoValidationError) ErrorName() string {
	return "CoboTransaction_BlockInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_BlockInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_BlockInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_BlockInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_BlockInfoValidationError{}

// Validate checks the field values on CoboTransaction_Source with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_Source) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_Source with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_SourceMultiError, or nil if none found.
func (m *CoboTransaction_Source) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_Source) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceType

	// no validation rules for WalletId

	if len(errors) > 0 {
		return CoboTransaction_SourceMultiError(errors)
	}

	return nil
}

// CoboTransaction_SourceMultiError is an error wrapping multiple validation
// errors returned by CoboTransaction_Source.ValidateAll() if the designated
// constraints aren't met.
type CoboTransaction_SourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_SourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_SourceMultiError) AllErrors() []error { return m }

// CoboTransaction_SourceValidationError is the validation error returned by
// CoboTransaction_Source.Validate if the designated constraints aren't met.
type CoboTransaction_SourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_SourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_SourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_SourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_SourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_SourceValidationError) ErrorName() string {
	return "CoboTransaction_SourceValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_SourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_Source.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_SourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_SourceValidationError{}

// Validate checks the field values on CoboTransaction_Destination with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_Destination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_Destination with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_DestinationMultiError, or nil if none found.
func (m *CoboTransaction_Destination) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_Destination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DestinationType

	// no validation rules for Address

	// no validation rules for ChangeAddress

	// no validation rules for Amount

	// no validation rules for WalletId

	// no validation rules for WalletType

	// no validation rules for WalletSubType

	if len(errors) > 0 {
		return CoboTransaction_DestinationMultiError(errors)
	}

	return nil
}

// CoboTransaction_DestinationMultiError is an error wrapping multiple
// validation errors returned by CoboTransaction_Destination.ValidateAll() if
// the designated constraints aren't met.
type CoboTransaction_DestinationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_DestinationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_DestinationMultiError) AllErrors() []error { return m }

// CoboTransaction_DestinationValidationError is the validation error returned
// by CoboTransaction_Destination.Validate if the designated constraints
// aren't met.
type CoboTransaction_DestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_DestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_DestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_DestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_DestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_DestinationValidationError) ErrorName() string {
	return "CoboTransaction_DestinationValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_DestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_Destination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_DestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_DestinationValidationError{}

// Validate checks the field values on CoboTransaction_UTXO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_UTXO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_UTXO with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_UTXOMultiError, or nil if none found.
func (m *CoboTransaction_UTXO) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_UTXO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxHash

	// no validation rules for VoutN

	if len(errors) > 0 {
		return CoboTransaction_UTXOMultiError(errors)
	}

	return nil
}

// CoboTransaction_UTXOMultiError is an error wrapping multiple validation
// errors returned by CoboTransaction_UTXO.ValidateAll() if the designated
// constraints aren't met.
type CoboTransaction_UTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_UTXOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_UTXOMultiError) AllErrors() []error { return m }

// CoboTransaction_UTXOValidationError is the validation error returned by
// CoboTransaction_UTXO.Validate if the designated constraints aren't met.
type CoboTransaction_UTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_UTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_UTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_UTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_UTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_UTXOValidationError) ErrorName() string {
	return "CoboTransaction_UTXOValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_UTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_UTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_UTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_UTXOValidationError{}

// Validate checks the field values on CoboTransaction_RawTxInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CoboTransaction_RawTxInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CoboTransaction_RawTxInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CoboTransaction_RawTxInfoMultiError, or nil if none found.
func (m *CoboTransaction_RawTxInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CoboTransaction_RawTxInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UsedNonce

	for idx, item := range m.GetSelectedUtxos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CoboTransaction_RawTxInfoValidationError{
						field:  fmt.Sprintf("SelectedUtxos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CoboTransaction_RawTxInfoValidationError{
						field:  fmt.Sprintf("SelectedUtxos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CoboTransaction_RawTxInfoValidationError{
					field:  fmt.Sprintf("SelectedUtxos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RawTx

	if len(errors) > 0 {
		return CoboTransaction_RawTxInfoMultiError(errors)
	}

	return nil
}

// CoboTransaction_RawTxInfoMultiError is an error wrapping multiple validation
// errors returned by CoboTransaction_RawTxInfo.ValidateAll() if the
// designated constraints aren't met.
type CoboTransaction_RawTxInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CoboTransaction_RawTxInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CoboTransaction_RawTxInfoMultiError) AllErrors() []error { return m }

// CoboTransaction_RawTxInfoValidationError is the validation error returned by
// CoboTransaction_RawTxInfo.Validate if the designated constraints aren't met.
type CoboTransaction_RawTxInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CoboTransaction_RawTxInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CoboTransaction_RawTxInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CoboTransaction_RawTxInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CoboTransaction_RawTxInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CoboTransaction_RawTxInfoValidationError) ErrorName() string {
	return "CoboTransaction_RawTxInfoValidationError"
}

// Error satisfies the builtin error interface
func (e CoboTransaction_RawTxInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoboTransaction_RawTxInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CoboTransaction_RawTxInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CoboTransaction_RawTxInfoValidationError{}
